* Ciljevi

sutra, stvarno idk:
 - pogledaj informativno:
   - https://www.youtube.com/watch?v=d5wL6eZnWMU
   - https://learnopengl.com/Getting-started/Textures
   - https://www.youtube.com/watch?v=qEfohFgQ1-I&t=298s
   - https://www.youtube.com/watch?v=2k5FjtMNQsM&t=1296s
 
 

trenutni cilj:
 - minimum viable product:
   - lopta koja se krece
   - kvadrat, svetlo?
   - basic shading na lopti
   - kretanje u creative mode, jako basic (posle mozes napravit ko u MC ili kako god)
posle toga:
 - ovaj /ceo/ chapter: https://learnopengl.com/Model-Loading/Assimp
 - cherno materials video-i, cherno textures video-i

* Renderer
** material

- Shader
- Shader data -> uniforms + textures
- Flags:
  - two-sided
  - depth test
  - blending
  - etc...

** 

https://learnopengl.com/Model-Loading/Assimp -> ona slika dole

Da bi submitovao treba ti:
 - Transform
 - Material
    - Texture bind
    - Shader bind
    - Uniform upload (object and globa/scene)
            shaderTexture.uploadUniform3f("u_LightPosition", gPointLightPosition);
            shaderTexture.uploadUniform3f("u_CameraPosition", camera.position);
            shaderTexture.uploadUniform1i("u_Texture", 1);
 - Vao
-----

To render you need:

- stanic:
  - mesh/renderable
    elementi: 
      - vertex array
      - model?
      - ?shader(bar info koji uzima, mozda?) mozda?
  - transformation matrix
  - ?position, scale?, rotation?

 * object:
     - vertex array
     - transformation matrix of cube
     - advanced: surface texture thing
     - shader
 * environment/scene:
     - camera, projection matrix
     - advanced: environemnts (lights...)

Submit stuff to queue, and render *only* after its all submited for a /lot/ of opmiziation n shit.

mesh = material + vertex array + transformation + shader ??

https://www.youtube.com/watch?v=akxevYYWd9g

** flow

for(entity list)
 if(entity.has(Mesh) and entity.has(Transform) and entity.isRenderable)
   gRenderManager.submit(const entity&);


ILI:
------

entity;
for(entity list)
 if(entity.doRender)
   gRenderManager.submit(const entity&);


//submit(shaderTexture, cubeVao, model);
//submit(entity.shaderthingIDK, entity.model, entity.model);

* Low prio

- preimenovati VertexArary u Vao
- preimenovati VetexBuffer u Vbo

low prio:
    =physicsmanager.setUp= preimenuj u physicsmanager.init(), i tako za sve setup sisteme
    preimenovati *_manager.[h,cpp] -> tipa *.[h,cpp]

* Compiler

Da moze da se kompajluje bez errora
Skontati koji flagovi, da li ide =-Wall= itd...
Skontati flagove za optimizaciju, release, debug, arhitekturu itd...
Binary moze da mi stoji u root directoriju zbog resources
Emulacija, najvrv visual studio jer je premocan, npr ono sto pise koliko vremena je gde proveo

cmake-generators

* beleske
** Static
- static local variable:
   lifetime -> entire program
   scope -> limited to that scope

** =delete =default
Stackoverflow odgovor: https://stackoverflow.com/a/6502854

** const

Zavsisi sa koje /strane/ =*= je =const=.

- =int const* A= $\equiv$ =const int* A=   -> ne mozes menjati A, mozes menjati gde pokazuje pointer

- =int * const a=                    -> mozes menjati A, ne mozes menjati gde pokazuje pointer

- =const= na kraju imena =metode= garantuje da metoda nece menjati clanove klase.
#+begin_src cpp
  class A{

    int b;
    int radi() const
    {
      cout << b;
    }

  };
#+end_src

** shader
- Finding uniform location does note require you to use the shader program first.

- Updating a uniform *does* require you to /first/ use the program. (da li moze update posle prvog koriscenja iako nije trentuno in-use???)
* Ideje za ecs

*nemoj ga praviti*

- Najvrv da svaki =entity= moze da ima po jedan od svakog =component=, tako i profesionalni ecs radi.

- Svaki entity ima svoj ID.

- U listi komponenti, svaka komponenta ima svoj ID. Onda ces moci dobiti sve ostale informacije vezane za taj entity ID.

- U listi komponenti, svaka komponenta ima svoj =bool= koji oznacava da li da je sistem /ignorise/ (tojest da li je "obrisana") ili da je sistem koristi (renderuje/physics-uje itd...)

Proveravanje da li ima bilo koji broj komponenti u O(1):
    - Da bi proverio da li neki entity ima recimo: transform i mesh, radim preko *bit-flagova* i bit operaciaj, kazem entity.has(TRANSFORM_COMPONENT_FLAG & MESH_COMPONENT_FLAG)
Uzimanje pointer od komponente u O(1):
    - Samo /store-uj/ pointere ka svim komponentama.
-----

kompnente:

template T -> id komponente tipa T (idk) -> return pointer tipa T

* Optimizacija

Cach-iranje pozicija uniform-ova u shader-u pri kompajlovanju

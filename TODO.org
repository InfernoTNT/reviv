* Ciljevi

sutra cilj:
 - MVP, samo staniceva faca na kocki da se rotira oko mene (pogledaj TODOO, gRenderManager.[update, setup]
 - object lifetime, ownership stuff, raii, reference counting...
   - https://www.youtube.com/watch?v=sLlGEUO_EGE
   - writing your own:
     - scope based pointer - equivalent of std::unique_pointer
     - reference counting system - equivalent of std::shared_pointer
     - weight references? (nisam dobro cuo cherno-a vrv)
 - entity class deep copy (copy construktor ili obicna funkcija)
 - transfer projekta u ecs
 
 

trenutni cilj:
 - minimum viable product:
   - lopta koja se krece
   - kvadrat, svetlo?
   - basic shading na lopti
   - kretanje u creative mode, jako basic (posle mozes napravit ko u MC ili kako god)
posle toga:
 - ovaj /ceo/ chapter: https://learnopengl.com/Model-Loading/Assimp
 - cherno materials video-i, cherno textures video-i

** 

Kako razviti veliki kvalitetan kod?
 - Prvo napravis MVP /(minimum viable product)/, i onda /iteracijama/ poboljsavas kod.

* Renderer
** material

*** 
- Shader
- Shader data -> uniforms + textures
- Flags:
  - two-sided
  - depth test
  - blending
  - etc...

*** 

neki =uniformi= su vezani za =materijal=, a neki za =renderer/scenu=.
renderer/scena:
 - pozicija svetlosti
 - pozicija predmeta
 - projection matrix
 - view matrix
 - transformation matrix

-----

#+begin_src cpp
  Material* material = new Material(m_FlatColorShader)
  material->set("u_Color", redColor);
  //squareMesh->setMaterial(material);   -   mozda, al msm da ne, dodaj mesh-ove jednog dana ako budu tada potrebni, al do tada stvarno nemoj
  // ml->setTexture("asdf", texture);  -  ili ml->set("asdf", texture);      -> texture= texture reference? texture classa?
#+end_src

Konstrukcija shadera. Ovo *nije* nesto bitno, napravi ako ti je dosadno.
#+begin_src cpp
  shader = Shader::Create("Ime_Shadera", const std::string& vetexSrc, const std::string& fragmentSrc);
  // Koristi ime (prvi argument) umesto ID, jer je vise human readable
#+end_src

Kad renderujes: 

#+begin_src cpp
  void RenderManager::submit(material, vao, transform)
  {
    material.bind();
    //vao....
    //transformstuff
  }

  void material.bind()
  {
    shader.bind()
    shader.setdata
    shader.setdata
    shader.setdata
    shader.setdata
  }
#+end_src
jedna moja ideja kako implementirati to "set"-ovanje:
    void set(const std::string& s, mat::Vec3 color);
    hash za ovaj string koji dobijes
    svaki put kada renderuje treba da set-uje te stvari? ili samo kada se promene pa mozda da skonta preko pointera????
          cherno -> std::unordered_map<std::string, Ref<Shader>> m_Shaders;
 
** 

https://learnopengl.com/Model-Loading/Assimp -> ona slika dole

Da bi submitovao treba ti:
 - Transform
 - Material
    - Texture bind
    - Shader bind
    - Uniform upload (object and globa/scene)
            shaderTexture.uploadUniform3f("u_LightPosition", gPointLightPosition);
            shaderTexture.uploadUniform3f("u_CameraPosition", camera.position);
            shaderTexture.uploadUniform1i("u_Texture", 1);
 - Vao
--------------

To render you need:

- stanic:
  - mesh/renderable
    elementi: 
      - vertex array
      - model?
      - ?shader(bar info koji uzima, mozda?) mozda?
  - transformation matrix
  - ?position, scale?, rotation?

 * object:
     - vertex array
     - transformation matrix of cube
     - advanced: surface texture thing
     - shader
 * environment/scene:
     - camera, projection matrix
     - advanced: environemnts (lights...)

Submit stuff to queue, and render *only* after its all submited for a /lot/ of opmiziation n shit.

mesh = material + vertex array + transformation + shader ??

https://www.youtube.com/watch?v=akxevYYWd9g

** flow

for(entity list)
 if(entity.has(Mesh) and entity.has(Transform) and entity.isRenderable)
   gRenderManager.submit(const entity&);


ILI:
------

entity;
for(entity list)
 if(entity.doRender)
   gRenderManager.submit(const entity&);


//submit(shaderTexture, cubeVao, model);
//submit(entity.shaderthingIDK, entity.model, entity.model);

* Low prio

- preimenovati VertexArary u Vao
- preimenovati VetexBuffer u Vbo

low prio:
    =physicsmanager.setUp= preimenuj u physicsmanager.init(), i tako za sve setup sisteme
    preimenovati *_manager.[h,cpp] -> tipa *.[h,cpp]

* Compiler

Da moze da se kompajluje bez errora
Skontati koji flagovi, da li ide =-Wall= itd...
Skontati flagove za optimizaciju, release, debug, arhitekturu itd...
Binary moze da mi stoji u root directoriju zbog resources
Emulacija, najvrv visual studio jer je premocan, npr ono sto pise koliko vremena je gde proveo

cmake-generators

* beleske
** Static
- static local variable:
   lifetime -> entire program
   scope -> limited to that scope

** =delete =default
Stackoverflow odgovor: https://stackoverflow.com/a/6502854

** const

Zavsisi sa koje /strane/ =*= je =const=.

- =int const* A= $\equiv$ =const int* A=   -> ne mozes menjati A, mozes menjati gde pokazuje pointer

- =int * const a=                    -> mozes menjati A, ne mozes menjati gde pokazuje pointer

- =const= na kraju imena =metode= garantuje da metoda nece menjati clanove klase.
#+begin_src cpp
  class A{

    int b;
    int radi() const
    {
      cout << b;
    }

  };
#+end_src

** shader
- Finding uniform location does note require you to use the shader program first.

- Updating a uniform *does* require you to /first/ use the program. (da li moze update posle prvog koriscenja iako nije trentuno in-use???)
* Ideje za ecs

za basic ecs (malkice bolja verzija mozda ovog mog, ili bar malo vise citka mozda): https://stackoverflow.com/questions/17058701/member-function-called-only-on-initialization-of-first-instance-of-a-class-c

*nemoj ga praviti*

- Najvrv da svaki =entity= moze da ima po jedan od svakog =component=, tako i profesionalni ecs radi.

- Svaki entity ima svoj ID.

- U listi komponenti, svaka komponenta ima svoj ID. Onda ces moci dobiti sve ostale informacije vezane za taj entity ID.

- U listi komponenti, svaka komponenta ima svoj =bool= koji oznacava da li da je sistem /ignorise/ (tojest da li je "obrisana") ili da je sistem koristi (renderuje/physics-uje itd...)

Proveravanje da li ima bilo koji broj komponenti u O(1):
    - Da bi proverio da li neki entity ima recimo: transform i mesh, radim preko *bit-flagova* i bit operaciaj, kazem entity.has(TRANSFORM_COMPONENT_FLAG & MESH_COMPONENT_FLAG)
Uzimanje pointer od komponente u O(1):
    - Samo /store-uj/ pointere ka svim komponentama.
-----

kompnente:

template T -> id komponente tipa T (idk) -> return pointer tipa T

* Optimizacija

Cach-iranje pozicija uniform-ova u shader-u pri kompajlovanju

Koristiti std::array umesto std::vector, zbog heap allocation shita - kaze Cherno. Ili napraviti svoju implementaciju vektora ili array-a

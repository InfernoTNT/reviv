* Ciljevi

danas:
 - implementacija ecs u /ograniceni/ kod projekta
 - copy constructor pogledati, i popraviti gde vidim, const reference, default constructor itd...
 - onaj chernov video (entt introduction)
 - renderer flow?

proveriti "has"
align: has "Position" "Rotation"

trenutni cilj:
 - minimum viable product:
   - lopta koja se krece
   - kvadrat, svetlo?
   - basic shading na lopti
   - kretanje u creative mode, jako basic (posle mozes napravit ko u MC ili kako god)

* Renderer

** 

To render you need:

- stanic:
  - mesh/renderable
    elementi: 
      - vertex array
      - model?
      - ?shader(bar info koji uzima, mozda?) mozda?
  - transformation matrix
  - ?position, scale?, rotation?

 * object:
     - vertex array
     - transformation matrix of cube
     - advanced: surface texture thing
     - shader
 * environment/scene:
     - camera, projection matrix
     - advanced: environemnts (lights...)

Submit stuff to queue, and render *only* after its all submited for a /lot/ of opmiziation n shit.

mesh = material + vertex array + transformation + shader ??

https://www.youtube.com/watch?v=akxevYYWd9g

** flow

for(entity list)
 if(entity.has(Mesh) and entity.has(Transform) and entity.isRenderable)
   gRenderManager.submit(const entity&);


ILI:
------

entity;
for(entity list)
 if(entity.doRender)
   gRenderManager.submit(const entity&);


//submit(shaderTexture, cubeVao, model);
//submit(entity.shaderthingIDK, entity.model, entity.model);



* Low prio

- preimenovati VertexArary u Vao
- preimenovati VetexBuffer u Vbo

low prio:
    =physicsmanager.setUp= preimenuj u physicsmanager.init(), i tako za sve setup sisteme
    preimenovati *_manager.[h,cpp] -> tipa *.[h,cpp]

* Compiler

Da moze da se kompajluje bez errora
Skontati koji flagovi, da li ide =-Wall= itd...
Skontati flagove za optimizaciju, release, debug, arhitekturu itd...
Binary moze da mi stoji u root directoriju zbog resources
Emulacija, najvrv visual studio jer je premocan, npr ono sto pise koliko vremena je gde proveo

cmake-generators

* beleske
** Static
- static local variable:
   lifetime -> entire program
   scope -> limited to that scope

** =delete =default
Stackoverflow odgovor: https://stackoverflow.com/a/6502854

** const

Zavsisi sa koje /strane/ =*= je =const=.

- =int const* A= $\equiv$ =const int* A=   -> ne mozes menjati A, mozes menjati gde pokazuje pointer

- =int * const a=                    -> mozes menjati A, ne mozes menjati gde pokazuje pointer

- =const= na kraju imena =metode= garantuje da metoda nece menjati clanove klase.
#+begin_src cpp
  class A{

    int b;
    int radi() const
    {
      cout << b;
    }

  };
#+end_src

* Ideje za ecs

*nemoj ga praviti*

- Najvrv da svaki =entity= moze da ima po jedan od svakog =component=, tako i profesionalni ecs radi.

- Svaki entity ima svoj ID.

- U listi komponenti, svaka komponenta ima svoj ID. Onda ces moci dobiti sve ostale informacije vezane za taj entity ID.

- U listi komponenti, svaka komponenta ima svoj =bool= koji oznacava da li da je sistem /ignorise/ (tojest da li je "obrisana") ili da je sistem koristi (renderuje/physics-uje itd...)

Proveravanje da li ima bilo koji broj komponenti u O(1):
    - Da bi proverio da li neki entity ima recimo: transform i mesh, radim preko *bit-flagova* i bit operaciaj, kazem entity.has(TRANSFORM_COMPONENT_FLAG & MESH_COMPONENT_FLAG)
Uzimanje pointer od komponente u O(1):
    - Samo /store-uj/ pointere ka svim komponentama.
-----

kompnente:

template T -> id komponente tipa T (idk) -> return pointer tipa T

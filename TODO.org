* Ciljevi

glfw stuff:
 - double time = glfwGetTime();
 - q -> power off
 - is pressed and stuff, pogledaj cherno video
 - viewport stuff

- window apstraction
- camera noclip flying controler (ubaciti u physics sistem)
    - organizacija, singleton, materijali, rename update->onUpdate, init->init(), singleton na stvari
    - sandbox, .dll and stuff
- Material map da bude safe (?opratori, copy construtor?)


scene sigleton gde stoje sve komponente, i onda ne moram vise da stavim =extern gEntityList...= u svaki fajl. + jos mogu samo scene::CreateEntity()
https://www.youtube.com/watch?v=GfSzeAcsBb0&t=1224s @18:30 | emplace!! | std::forward.... | T&&...

convenience:
 - entity.transform (because every entity should have a transform) 
 - implicit cast operators
 - convenience operators(for transform)
 
ciljevi:
 - scene sigleton, entity UUID and string(for debug)
 - reference system
    - entity class deep copy
    - basic object lifetime
    - virtual destructor
-----
 - clean RenderManager::init() | cherno serijalizacija? | cherno singleton?
   - ? glfwInit(), glInit() ?
 - materijali da rade kako treba (materijali da rade kako treba), efikasno 
 - /ceo/ chapter https://learnopengl.com/Model-Loading/Assimp
   
mozda rename =getComponent()= -> get(), isto i za =has= i =set= nesto mozda?

class Scene
{
    Entity CreateEntity(const std::string& name = std::string()); // *bitan je return*
}

-----
ciljevi:
 - Entity* Scene::createEntity(const std::string& name = std::string()); // *bitan je return*
 - MaterialComponent* entity.get<MaterialComponent>()
 - entity.transform
 - entity.clear
 - MaterialComponent* entity.add<MaterialComponent>(Material(constructor_args)) // *RETURN JE BITAN*
 - MaterialComponent* entity.emplace<MaterialComponent(contructor_args) //bolje  *RETURN JE BITAN*
 - bool entity.has<MaterialComponent>
 - ?entity.name?
 - ?entity name search?
-----
* Renderer
** material
*** 
- Shader
- Shader data -> uniforms + textures
- Flags:
  - two-sided
  - depth test
  - blending
  - etc...

Jedno potencijalno resenje za =light uniforme= je navodno "light manager" koji se pokrece unutar render loop-a.

*** 

neki =uniformi= su vezani za =materijal=, a neki za =renderer/scenu=.
renderer/scena:
 - pozicija svetlosti
 - pozicija predmeta
 - projection matrix
 - view matrix
 - transformation matrix

-----

#+begin_src cpp
  Material* material = new Material(m_FlatColorShader)
  material->set("u_Color", redColor);
  //squareMesh->setMaterial(material);   -   mozda, al msm da ne, dodaj mesh-ove jednog dana ako budu tada potrebni, al do tada stvarno nemoj
  // ml->setTexture("asdf", texture);  -  ili ml->set("asdf", texture);      -> texture= texture reference? texture classa?
#+end_src

Konstrukcija shadera. Ovo *nije* nesto bitno, napravi ako ti je dosadno.
#+begin_src cpp
  shader = Shader::Create("Ime_Shadera", const std::string& vetexSrc, const std::string& fragmentSrc);
  // Koristi ime (prvi argument) umesto ID, jer je vise human readable
#+end_src

Kad renderujes: 

#+begin_src cpp
  void RenderManager::submit(material, vao, transform)
  {
    material.bind();
    //vao....
    //transformstuff
  }

  void material.bind()
  {
    shader.bind()
    shader.setdata
    shader.setdata
    shader.setdata
    shader.setdata
  }
#+end_src
jedna moja ideja kako implementirati to "set"-ovanje:
    void set(const std::string& s, mat::Vec3 color);
    hash za ovaj string koji dobijes
    svaki put kada renderuje treba da set-uje te stvari? ili samo kada se promene pa mozda da skonta preko pointera????
          cherno -> std::unordered_map<std::string, Ref<Shader>> m_Shaders;
 
* Compiler

Da moze da se kompajluje bez errora
Skontati koji flagovi, da li ide =-Wall= itd...
Skontati flagove za optimizaciju, release, debug, arhitekturu itd...
Binary moze da mi stoji u root directoriju zbog resources
Emulacija, najvrv visual studio jer je premocan, npr ono sto pise koliko vremena je gde proveo

cmake-generators

* beleske
** Static
- static local variable:
   lifetime -> entire program
   scope -> limited to that scope

stvari koje cine static cini mi se:
 - inicijalizacija se radi samo jednom
 - program life time
 - local to that scope

** =delete =default
Stackoverflow odgovor: https://stackoverflow.com/a/6502854

** const

Zavsisi sa koje /strane/ =*= je =const=.

- =int const* A= $\equiv$ =const int* A=   -> ne mozes menjati A, mozes menjati gde pokazuje pointer

- =int * const a=                    -> mozes menjati A, ne mozes menjati gde pokazuje pointer

- =const= na kraju imena =metode= garantuje da metoda nece menjati clanove klase.
#+begin_src cpp
  class A{

    int b;
    int radi() const
    {
      cout << b;
    }

  };
#+end_src

** shader
- Finding uniform location does note require you to use the shader program first.

- Updating a uniform *does* require you to /first/ use the program. (da li moze update posle prvog koriscenja iako nije trentuno in-use???)
** pointers
Cherno kaze: On /licno/ koristi ili =shared pointer= ili =raw pointer=. U praksi ne koristi =unique pointer= jer se oni koriste kada je bitna performansa, a tada /might as well use raw/.
https://www.youtube.com/watch?v=HkGZ378nArE
https://www.youtube.com/watch?v=sLlGEUO_EGE
Comment your .h files
** resursi (knjige, artikli itd)

Three optimizatoin tips for c++ (preporuka od game engine book): https://www.slideshare.net/andreialexandrescu1/
- game dev -> left handed coordinate system

gang of four - design patterns of OOP (game engine book prepourka)
** order of class members

moje licno:
    1. public
    2. private

    1. typedefs adn enums
    2. constants
    3. constructor
    4. destructor
    5. static methods
    6. methods
    7. static data member
    8. data member

* Ideje za ecs
** entt api

- entt::entity entity = m_Registry.create(); //m_Registry $\approx$ scene, entt::entity = uint32_t

- m_Registry.emplace<TransformComponent>(entity); (RADI RETURN)
- m_Registry.emplace<TransformComponent>(entity, construstor_arguments); //https://www.youtube.com/watch?v=D4hz0wEB978&t=1304s @22:00

napravi =entity.add<TransformComponent>(constructor_args);= ili =EntityManager::add<TransformComponent>(entity, constructor_args)= (drugi je mozda komplikovan)

- m_Registry.remove<TransformComponent>(entity)

- m_Registry.clear()

- m_Registry.get<TransformComponent>(entity)

- if(m_Registry.has<TransformComponent>(entity))

TransformComponent& transform = m_Registry.emplace<TransformComponent>(entity, constructor_args); // *brutalno*
auto& transform = m_Registry.emplace<TransformComponent>(entity, constructor_args); // *brutalno*

Radi funkciju /onTransformConstruct/ na svakoj konstrukciji transforma.
    m_Registry.on_construct<TransformComponent>().connect<&onTransformConstruct>();
    m_Registry.on_destruct...
    m_Registry.on_destroy...
    m_Registry.on_update...
    m_Registry.on_replace...
            static void onTransformConstruct(entt:registry& registry, entt:entity entity);
   

*** Prolazenje/iteracija:

auto view = m_Registry.view<TransformComponent>();
for (auto entity: view)
{
    auto& TransformComponent = m_Registry.get<TransformComponent>(entity);
}

*iteracija kroz grupe*:
auto group = m_Registry.group<TransformComponent>(entt:get<MeshComponent>);
for (auto entity : group)
{
    auto&[transform, mesh] = group.get<TransformComponent, MeshComponent>(entity); // *C++ 17*
}

** cherno api

bool entity.hasComponent<TransformComponent>();

auto& squareColor = m_SquareEntity.GetComponent<SpriteRendererComponent>().Color; *RETURN TYPE Je T**

** 
za basic ecs (malkice bolja verzija mozda ovog mog, ili bar malo vise citka mozda): https://stackoverflow.com/questions/17058701/member-function-called-only-on-initialization-of-first-instance-of-a-class-c

https://github.com/SanderMertens/ecs-faq

*nemoj ga praviti*

- Najvrv da svaki =entity= moze da ima po jedan od svakog =component=, tako i profesionalni ecs radi.

- Svaki entity ima svoj ID.

- U listi komponenti, svaka komponenta ima svoj ID. Onda ces moci dobiti sve ostale informacije vezane za taj entity ID.

- U listi komponenti, svaka komponenta ima svoj =bool= koji oznacava da li da je sistem /ignorise/ (tojest da li je "obrisana") ili da je sistem koristi (renderuje/physics-uje itd...)

Proveravanje da li ima bilo koji broj komponenti u O(1):
    - Da bi proverio da li neki entity ima recimo: transform i mesh, radim preko *bit-flagova* i bit operaciaj, kazem entity.has(TRANSFORM_COMPONENT_FLAG & MESH_COMPONENT_FLAG)
Uzimanje pointer od komponente u O(1):
    - Samo /store-uj/ pointere ka svim komponentama.
-----

kompnente:

template T -> id komponente tipa T (idk) -> return pointer tipa T

* Optimizacija

Cach-iranje pozicija uniform-ova u shader-u pri kompajlovanju

Koristiti std::array umesto std::vector, zbog heap allocation shita - kaze Cherno. Ili napraviti svoju implementaciju vektora ili array-a

Za voxel based:
 - frustum culling
 - occlusion culling
 - rendering only visible faces
 - several articles and videos about it, heck there is even an stb library
 - ?sean's toolbox?

* Long term ideje

camera.renderTarget(Entity)  ->  track-uje neki entity

class SpecificComponent : public Component
 static getName()
 static std::string name;

Svaki Component da ima svoj (ne virtualan) id.

In order to render a skeletal mesh, the game engine requires three distinct kinds of data:
1. the mesh itself,
2. the skeletal hierarchy (joint names, parent-child relationships and the
base pose the skeleton was in when it was originally bound to the mesh),
and
58 1. Introduction
3. one or more animation clips, which specify how the joints should move
over time.

* Resursi
https://antongerdelan.net/opengl/
https://open.gl/
